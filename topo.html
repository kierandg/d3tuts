<!DOCTYPE html>
<html>
<head>
    <title>Page Title</title>
    <style type="text/css">
        #wrapper {
            padding-top: 35px;
        }

        #map-canvas {
            height: 600px;
            width: 1000px;
            margin: 0 auto;
        }

        #loading {
            padding-top: 15px;
            width: 200px;
            margin: 0 auto;
        }

        /* On mouse hover, lighten state color */
        .feature:hover {
            fill: yellow;
            fill-opacity: .35;
        }

        .active .feature {
            fill: yellow;
            opacity: 0.75;
        }

        .city-label {
            font: 12px "Helvetica Neue", Helvetica, Arial, sans-serif;
            pointer-events: none;
            fill: #444;
            fill-opacity: .75;
        }

        .state-label {
            fill: #777 !important;
            fill-opacity: .5;
            font-size: 8px;
            text-anchor: middle;
            pointer-events: none;
        }

        .feature {
            cursor: pointer;
        }

        .country-boundary {
            fill: none;
            stroke: #37C3BC;
            stroke-linejoin: round;
        }

        .state-boundary {
            fill: none;
            stroke: #003568;
            stroke-dasharray: 5,3;
            stroke-linejoin: round;
            stroke-linecap: round;
            vector-effect: non-scaling-stroke;
        }

        /* http://colorbrewer2.org/ */
        .q0-9 {
            fill: #F7FCF0;
        }

        .q1-9 {
            fill: #E0F3DB;
        }

        .q2-9 {
            fill: #CCEBC5;
        }

        .q3-9 {
            fill: #A8DDB5;
        }

        .q4-9 {
            /* lighten #7BCCC4 */
            fill: #BBF3FF;
        }

        .q5-9 {
            /* lighten #4EB3D3 */
            fill: #A1D9FF;
        }

        .q6-9 {
            /* lighten #2B8CBE */
            fill: #87BFFF;
        }

        .q7-9 {
            /* lighten #0868AC */
            fill: #6EA6E7;
        }

        .q8-9 {
            /* lighten #084081 */
            fill: #558DCE;
        }

        .state-label.q5-9 {
            fill: #A8DDB5 !important;
        }

        .state-label.q6-9 {
            fill: #CCEBC5 !important;
        }

        .state-label.q7-9 {
            fill: #E0F3DB !important;
        }

        .state-label.q8-9 {
            fill: #F7FCF0 !important;
        }

        .overlay {
            fill: none;
            pointer-events: all;
        }

        .fa-spinner {
            -webkit-animation: spin 1300ms infinite linear;
            -moz-animation: spin 1300ms infinite linear;
            -ms-animation: spin 1300ms infinite linear;
            -o-animation: spin 1300ms infinite linear;
            animation: spin 1300ms infinite linear;
            font-size: 41px;
            text-decoration: none;
            color: #C0C0C0;
        }

        .hidden {
            display: none;
            visibility: hidden;
        }

        div.tooltip {
            position: absolute;
            text-align: center;
            width: 60px;
            height: 28px;
            padding: 2px;
            font: 12px sans-serif;
            background: lightsteelblue;
            border: 0px;
            border-radius: 8px;
            pointer-events: none;
        }

        @-webkit-keyframes spin {
            to {
                -webkit-transform: rotate(360deg);
            }
        }

        @-moz-keyframes spin {
            to {
                -moz-transform: rotate(360deg);
            }
        }

        @-ms-keyframes spin {
            to {
                -ms-transform: rotate(360deg);
            }
        }

        @-o-keyframes spin {
            to {
                -o-transform: rotate(360deg);
            }
        }

        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }
    </style>
    <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.1.0/css/font-awesome.min.css" rel="stylesheet">
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.min.js"></script>
    <script src="https://d3js.org/d3.v3.min.js"></script>
    <script src="https://d3js.org/topojson.v1.min.js"></script>
    <script>
        var width = 960,
        height = 600;
        var active = d3.select(null);

        // We create a quantile scale to categorize the values in 5 groups.
        // The domain is static and has a minimum/maximum of population/density.
        // The scale returns text values which can be used for the color CSS
        // classes (q0-9, q1-9 ... q8-9)
        var quantiles = d3.scale.quantile()
            .range(d3.range(9).map(function (i) { return 'q' + i + '-9'; }));

        //var clr = d3.scale.linear()
        //    //.range(['beige', 'red']);
        //    .range(['#FFF7EC', '#7F0000']);

        var svg, g, centered, path, zoom, projection;

        $(document).ready(function () {
            // Area, population and population density in 2011 by province
            // get from https://www.gso.gov.vn
            // Average population (Thous. pers.)/Area (Km2)/Population density (Person/km2)

            // Load in popuplation data with D3 (or jQuery)

            d3.select('#loading').classed('hidden', false);
            d3.csv('vn-population-2011.csv', function (error, rows) {
                if (error) {
                    return console.warn(error);
                }

                loadTopoJson(rows);
            });
        });

        function loadTopoJson(data) {

            // @see http://www.gadm.org/
            // GADM is a spatial database of the location of the world's
            // administrative areas (or adminstrative boundaries) for use in GIS and similar software.
            // @see http://mapshaper.org/ for simplify
            // A tool for topologically aware shape simplification. Reads and
            // writes Shapefile, GeoJSON and TopoJSON formats.
            d3.json('vn-states.json', function (error, json) {

                if (error) {
                    return console.warn(error);
                }

                d3.select('#loading').classed('hidden', true);

                // While our data can be stored more efficiently in TopoJSON,
                // we must convert back to GeoJSON for display.
                var features = topojson.feature(json, json.objects.states).features;

                // Merge the ag. data and GeoJSON
                // Loop through once for each ag. data value
                for (var i = 0; i < data.length; i++) {
                    // Grab state name
                    var dataIso = data[i].iso;
                    // Grab data value, and convert from string to float
                    var density = parseFloat(data[i].density);
                    var population = parseFloat(data[i].population);

                    //Find the corresponding state inside the GeoJSON
                    for (var j = 0; j < features.length; j++) {

                        var jsonIso = features[j].properties.iso;
                        if (dataIso == jsonIso) {
                            // Copy the data value into the JSON
                            features[j].properties.density = density;
                            features[j].properties.population = population;

                            // Stop looking through the JSON
                            break;
                        }
                    }
                }

                // Set the domain of the values
                quantiles.domain(features.map(function (d) {
                    return d.properties.density;
                }));

                drawMap(json, features);
            });
        }

        function drawMap(json, features) {
            // @see http://geojson.org/
            // Create a first guess for the projection
            //var center = d3.geo.centroid(json);
            var center = [106.34899620666437, 16.553160650957434];
            var scale = 4000;
            var offset = [width / 2, height / 2 - 300];

            // The projection function takes a location [longitude, latitude]
            // and returns a Cartesian coordinates [x,y] (in pixels).
            //
            // D3 has several built-in projections. Albers USA is a composite projection
            // that nicely tucks Alaska and Hawaii beneath the Southwest.
            //
            // Albers USA (albersUsa) is actually the default projection for d3.path.geo()
            // The default scale value is 1,000. Anything smaller will shrink the map;
            // anything larger will expand it.
            //
            // Add a scale() method with 800 to our projection in order to shrink things down a bit
            // var projection = d3.geo.albersUsa()
            //                      .translate([w/2, h/2]).scale([800]);
            projection = d3.geo.mercator()
                .translate(offset)
                .scale([scale])
                .center(center);

            // We define our first path generator for translating that
            // mess of GeoJSON coordinates into even messier messes of SVG path codes.
            // Tell the path generator explicitly that it should reference our customized
            // projection when generating all those paths
            path = d3.geo.path()
                 .projection(projection);

            zoom = d3.behavior.zoom()
                .translate([0, 0])
                .scale(1)
                .scaleExtent([1, 13])
                .on('zoom', zoomed);

            svg = d3.select('#map-canvas').append('svg')
                .attr('width', width)
                .attr('height', height)
                // Not process on click event and stop propagation
                .on('click', stopped, true);

            // Append div for tooltip to SVG
            var div = d3.select('body')
                .append('div')
                .attr('class', 'tooltip')
                .style('opacity', 0);

            svg.append('rect')
                .attr('class', 'overlay')
                .attr('width', width)
                .attr('height', height);

            g = svg.append('g');

            // Create g before call zoom
            svg
                .call(zoom)                 // delete this line to disable free zooming
                .call(zoom.event)
                .on('dblclick.zoom', null);

            //-----------------------------------------------------------------
            // For country boundary and state mesh/not data binding
            //-----------------------------------------------------------------
            var boundary = g.append('g')
                .attr('class', 'boundary');

            g
                .attr('class', 'states')
                .selectAll('path')          // select all the current path nodes
                .data(features)             // bind these to the features array in json
                .enter().append('g')        // if not enough elements create a new group
                .attr('class', function (d) {
                    return 'state state-' + d.properties.iso;
                })
                .on('click', clicked)
                .append('path')
                .attr('class', function (d) {
                    // Use the quantiled value for the class
                    return 'feature ' + quantiles(d.properties.density);
                })    // add attribute class and fill with result from quantiles
                .attr('d', path);

            //-----------------------------------------------------------------
            // Now we can draw boundary, prevent lost data cause by merging and meshing
            //-----------------------------------------------------------------
            // Country boundary from merge all geometries
            boundary.append('path')
                .attr('class', 'country-boundary')
                .datum(topojson.merge(json, json.objects.states.geometries))
                .attr('d', path);

            // State mesh
            boundary.append('path')
                .attr('class', 'state-boundary')
                .datum(topojson.mesh(json, json.objects.states, function (a, b) {
                    return a !== b;
                })).attr('d', path);
            //-----------------------------------------------------------------

            //-----------------------------------------------------------------
            // State names
            //-----------------------------------------------------------------
            g.append('g')
                .attr('class', 'state-labels')
                .selectAll('text')          // select all the current path nodes
                .data(features)
                .enter().append('text')     // if not enough elements create a text
                .attr('class', function (d) {
                    // To make contract text
                    var className = 'state-label state-' + d.properties.iso;
                    return className + ' ' + quantiles(d.properties.density);
                })
                .text(function (d) {
                    // Name from bound data we already binded using .data(features)
                    return d.properties.name;
                })
                // Using transform equivalent to x, y
                .attr('transform', function (d) { return 'translate(' + path.centroid(d) + ')'; })
                //.attr('x', function (d) {
                //    return path.centroid(d)[0];
                //})
                //.attr('y', function (d) {
                //    return path.centroid(d)[1];
                //})
                // The dy attribute indicates a shift along the y-axis on the position
                // of an element or its content. What exactly is shifted
                // depends on the element for which this attribute is set.
                .attr('dy', '.35em');

            drawCities();

            d3.select(self.frameElement).style('height', height + 'px');
        }

        function drawCities() {
            // Cities group
            g.append('g')
                .attr('class', 'cities');

            d3.csv('vn-cities.csv', function (error, rows) {
                if (error) {
                    return console.warn(error);
                }

                rows.forEach(function (row, i) {
                    // Create new group and binding data
                    var sg = g.selectAll('.cities')
                        .append('g').datum(row)
                        .attr('class', function (d) {
                            return 'city city-' + d.code + ' level-' + d.level;
                        });

                    // Append circle to group of city
                    sg.append('circle')
                        .attr('class', function (d) {
                            return 'city-place';
                        })
                        .attr('visibility', function (d) {
                            return d.level < 3 ? 'visible' : 'hidden';
                        })
                        .attr('cx', function (d) {
                            return projection([d.lng, d.lat])[0];
                        })
                        .attr('cy', function (d) {
                            return projection([d.lng, d.lat])[1];
                        })
                        .attr('r', 2)
                        .style('fill', 'white')
                        .style('stroke', 'black')
                        .style('stroke-width', 2)
                        .style('opacity', 0.85)
                        // Modification of custom tooltip code provided by Malcolm Maclean, "D3 Tips and Tricks"
                        // http://www.d3noob.org/2013/01/adding-tooltips-to-d3js-graph.html
                        .on('mouseover', function (d) {
                            //div.transition()
                            //    .duration(200)
                            //    .style('opacity', .9);
                        })
                        // fade out
                        .on('mouseout', function (d) {
                            //div.transition()
                            //    .duration(500)
                            //    .style('opacity', 0);
                        });

                    sg.append('text')
                        .attr('class', function (d) {
                            return 'city-label';
                        })
                        .text(function (d) {
                            return d.name;
                        })
                        .attr('visibility', function (d) {
                            return d.level < 2 ? 'visible' : 'hidden';
                        })
                        .attr('x', function (d) {
                            return projection([d.lng, d.lat])[0];
                        })
                        .attr('y', function (d) {
                            return projection([d.lng, d.lat])[1];
                        })
                        .attr('text-anchor', function (d) {
                            return d.lng > 105.7 ? 'start' : 'end';
                        })
                        .attr('dx', function (d) {
                            return (d.lng > 105.7 ? 1 : -1) * 0.7 + 'em';
                        })
                        // The dy attribute indicates a shift along the y-axis on the position
                        // of an element or its content. What exactly is shifted
                        // depends on the element for which this attribute is set.
                        .attr('dy', '.35em');
                });
            });
        }

        function zoomed() {
            g.selectAll('.country-boundary').style('stroke-width', 1 / d3.event.scale + 'px');

            g.selectAll('.feature').style('stroke-width', 2 / (d3.event.scale + 0.5) + 'px');
            g.attr('transform', 'translate(' + d3.event.translate + ')scale(' + d3.event.scale + ')');

            g.selectAll('.state-label').style('font-size', (8 / d3.event.scale + 2) + 'px')

            g.selectAll('.city-place')
                .style('r', 1 / d3.event.scale + 0.7)
                .style('stroke-width', 2 / (d3.event.scale + 0.5) + 'px');

            g.selectAll('.city-label')
                .style('font-size', (12 / d3.event.scale + 1.5) + 'px')
                .attr('dy', d3.event.scale == 1 ? '0.35em' : (((1 / d3.event.scale) * 0.35 + 0.2) + 'em'));

            g.selectAll('.level-3 .city-label')
                .style('font-size', (6 / d3.event.scale + 1.5) + 'px');

            g.selectAll('.level-4 .city-label')
                .style('font-size', (5 / d3.event.scale + 1.5) + 'px');

            if (d3.event.scale < 2) {
                g.selectAll('.level-2 .city-label').attr('visibility', 'hidden');
            } else {
                g.selectAll('.level-2 .city-label').attr('visibility', 'visible');
            }

            if (d3.event.scale < 3.3) {
                g.selectAll('.level-3 .city-label').attr('visibility', 'hidden');
                g.selectAll('.level-3 .city-place').attr('visibility', 'hidden');

                g.selectAll('.level-4 .city-label').attr('visibility', 'hidden');
                g.selectAll('.level-4 .city-place').attr('visibility', 'hidden');
            } else {
                g.selectAll('.level-3 .city-label').attr('visibility', 'visible');
                g.selectAll('.level-3 .city-place').attr('visibility', 'visible');

                g.selectAll('.level-4 .city-label').attr('visibility', 'visible');
                g.selectAll('.level-4 .city-place').attr('visibility', 'visible');
            }
        }

        // If the drag behavior prevents the default click,
        // also stop propagation so we don’t click-to-zoom.
        function stopped() {
            if (d3.event.defaultPrevented) {
                d3.event.stopPropagation();
            }
        }

        function reset() {
            active.classed('active', false);
            active = d3.select(null);

            svg.transition()
                .duration(750)
                .call(zoom.translate([0, 0]).scale(1).event);
        }

        function clicked(d) {
            if (active.node() === this) {
                return reset();
            }

            active.classed('active', false);
            active = d3.select(this).classed('active', true);

            var bounds = path.bounds(d),
                dx = bounds[1][0] - bounds[0][0],
                dy = bounds[1][1] - bounds[0][1],
                x = (bounds[0][0] + bounds[1][0]) / 2,
                y = (bounds[0][1] + bounds[1][1]) / 2,
                scale = Math.max(1, Math.min(8, 0.9 / Math.max(dx / width, dy / height))),
                translate = [width / 2 - scale * x, height / 2 - scale * y];

            svg.transition()
                .duration(750)
                .call(zoom.translate(translate).scale(scale).event);
        }

        function starPoints(centerX, centerY, arms, outerRadius, innerRadius) {
            var results = '';

            var angle = Math.PI / arms;

            for (var i = 0; i < 2 * arms; i++) {
                // Use outer or inner radius depending on what iteration we are in.
                var r = (i & 1) == 0 ? outerRadius : innerRadius;

                var currX = centerX + Math.cos(i * angle) * r;
                var currY = centerY + Math.sin(i * angle) * r;

                // Our first time we simply append the coordinates, subsequet times
                // we append a ", " to distinguish each coordinate pair.
                if (i == 0) {
                    results = currX + ',' + currY;
                }
                else {
                    results += ', ' + currX + ',' + currY;
                }
            }

            return results;
        }
    </script>
</head>
<body>
    <div id="wrapper">
        <div id="map-canvas"></div>
        <div id="loading" class="hidden"><a class="fa fa-spinner"></a></div>
    </div>
</body>
</html>
